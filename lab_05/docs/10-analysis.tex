\chapter{Аналитическая часть}

Запросом будем называть сообщение (под сообщением подразумевается конечный набор байтов) в формате http запроса. Формат http выбран как самый популярный и простой формат клиент-серверного взаимодействия.

Ответом будет называть сообщение в формате http ответа.

В рамках данной лабораторной работы поставлена задача разработки серверного приложения. Серверным приложением будем называть endpoint, совершающий обработку запроса и возвращащий некоторый ответ.

Обработчик получает в теле запроса целое число - количество записей, которое необходимо вернуть. Возвращется фиксированное число государственных номеров автомобилей из базы данных.


\section{Протокол HTTP}

HTTP — протокол прикладного уровня передачи данных, изначально~—~в виде гипертекстовых документов в формате HTML, в настоящее время используется для передачи произвольных данных.

Формат http запроса состоит из:
\begin{itemize}
	\item Версии протокола.
	\item HTTP-метода, обычно глагола подобно GET, POST или существительного, как OPTIONS или HEAD, определяющее операцию, которую клиент хочет выполнить. Обычно, клиент хочет получить ресурс (используя GET) или передать значения HTML-формы (используя POST), хотя другие операция могут быть необходимы в других случаях.
	\item Пути к ресурсу.
	\item Заголовков с метаинформацией (опционально).
	\item Тела запроса, предворяемого пустой строкой (опционально).
\end{itemize}

Пример http запроса представлен в листинге 1.1.

\pagebreak
Формат http ответа состоит из:

\begin{itemize}
	\item Версии протокола.
	\item Код состояния. Наиболее популярными являются: 200 (запрос выполнен успешно), 4xx (плохой запрос), 5xx (внутренняя ошибка сервера).
	\item Сообщение состояния, например OK, Bad request, Internal Server Error.
	\item Заголовки с метаинформацией (опционально).		
	\item Тела ответа, предворяемого пустой строкой (опционально).
\end{itemize}

Пример http ответа представлен в листинге 1.2.

\begin{lstlisting}[caption=Пример http запроса]
	POST /echo/post/json HTTP/1.1
	Host: reqbin.com
	Authorization: Bearer mt0dgHmLJMVQhvjpNXDyA83vA_PxH23Y
	Content-Type: application/json
	Content-Length: 80
	
	{
		"Id": 12345,
		"Customer": "John Smith",
		"Quantity": 1,
		"Price": 10.00
	}
\end{lstlisting}

\pagebreak

\begin{lstlisting}[caption=Пример http ответа]
HTTP/1.1 201 Created
Location: http://localhost/objectserver/restapi/alerts/status/kf/12481%3ANCOMS
Cache-Control: no-cache
Server: libnhttpd
Date: Wed Jul 4 15:31:53 2012
Connection: Keep-Alive
Content-Type: application/json;charset=UTF-8
Content-Length: 304

{
	"entry":	{
		"affectedRows": 1,
		"keyField": "12481%3ANCOMS",
		"uri": "http://localhost/objectserver/restapi/alerts/status/kf/12481%3ANCOMS"
	}
}
\end{lstlisting}


\section{Серверное приложение}

Socket — название программного интерфейса для обеспечения обмена данными между процессами. Процессы при таком обмене могут исполняться как на одной ЭВМ, так и на различных ЭВМ, связанных между собой только сетью. Сокет — абстрактный объект, представляющий конечную точку соединения.

Для взаимодействия между машинами используются адреса и порты. Адрес представляет собой 32-битную структуру для протокола IPv4, 128-битную для IPv6. Номер порта — целое число в диапазоне от 0 до 65535. Эта пара и определяет сокет («гнездо», соответствующее адресу и порту).

Для выполнения задачи построения серверного приложения необходимо читать запросы, поступающие на определенный сокет, посылать их в обработчик и затем записывать их по другому сокету, созданному для принятия ответа.

\section{Рапараллеливание обработки запросов}

Для решения поставленной задачи обработки запросов существует несколько способов организации параллельности вычислений:

\begin{itemize}
	\item Выполнять все в одном потоке. Такой подход является неэффективным, так как пока не будет выполнен первый запрос, поступивший на обработчик следующий запрос не будет взят в работу. 
	\item Обработка каждого запроса в отдельном потоке. Такой подход также не является эффективным, так как при высокой загруженности такого серверного приложения количество потоков в системе может стать слишком большим и значительная часть процессорного времени будет тратиться на организацию работы потоков, а не на обработку самих запросов.
	\item Создание системы с фиксированным числом потоков, где один поток занимается лишь чтением запросов, поступающих на сокет, а остальные обрабатывают запросы и посылают ответы. Данный подход кажется оптимальным в данной ситуации, однако трубует дополнительного анализа для поиска оптимального числа потоков.
\end{itemize}


Последний пункт может быть формализован как реализация модели пула потоков. Данная модель параллельных вычислений состоит в организации работы следующих сущностей:
\begin{itemize}
	\item производитель, роль которого заключаются в отправке задач в общую очередь задач;
	\item очередь задач, роль которой заключется в накоплении задач производителя и из передаче потребителю;
	\item потребители, роли которых заключаются в забирании задач из очереди и их обработке.
\end{itemize}

Схему работы пула потоков более наглядно можно проследить на рисунке 1.1.


\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.9\linewidth]{img/thread_pool.png}
	\caption{Схема работы пула потоков}
	\label{fig:tp}
\end{figure}

Развивая данную идею получено, что каждый потребитель может передавать ставить задачи слеующему потребителю, тем самым выступая проихводителем. Такая организация вычислений называется конвеер.

\section*{Вывод}

Рассмотрены теоретические построения серверного приложения. Получены знания, достаточные для перехода к программной реализации задачи.

\clearpage